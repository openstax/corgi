#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    # If the script is sourced, handle aliases and exit early
    if [[ -z "$PS1_PREV_CORGI" ]]; then
        here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        # shellcheck disable=SC2139
        alias corgi="$here/corgi"
        # shellcheck disable=SC2139
        alias npm="command npm --prefix \"$here/frontend\""
        PS1_PREV_CORGI="$PS1"
        PS1="(corgi) $PS1"
    else
        PS1="$PS1_PREV_CORGI"
        unalias corgi
        unalias npm
        unset PS1_PREV_CORGI
    fi
    return 0
else
    # Script is being executed
    set -eo pipefail
fi

_die() {
    echo "$@" >&2
    exit 1
}

_list_commands() {
    declare -F | awk '$NF !~ /^_/ { print $NF }'
}

_find_command() {
    _list_commands | grep -xF "$1"
}

_usage() {
    cat <<EOF
Manage your local corgi stack
Usage:

    corgi <COMMAND> [arguments]

The commands are:
    start-bare-metal            Start without virtualization
    start                       Alias for start-leashed
    start-dev                   Start corgi in dev mode (requires oauth app, see README for more details)
    start-leashed               Start corgi in leashed mode (uses mocked GitHub API)
    create-jobs [TOKEN]         Creates sample jobs with each type and status (token is required in dev mode)
    create-erd                  Creates an Entity-relationship diagram (ERD) using data int he CORGI database
    build   <STACK_NAME>        Build all images in the stack
    restart <STACK_NAME>        Restart all containers in the stack
    logs                        See logs (supports same options as docker compose logs)
    ui-tests <BASE_URL> [TOKEN] Run UI tests (playwright) on BASE_URL. These can run without a github token
                                on localhost, but otherwise a token with correct accesslevel is required (see README).
                                You may optionally specify a subset of tests to run as the last positional argument.
    unit-tests-backend          Run unit tests for backend inside a container. Updates snapshots. You may optionally
                                specify a subset of tests to run as the last positional argument.
    generate-migration          Shortcut for alembic revision --autogenerate -m (See README for more details)
    create-approved-books       Create some approved book entries from data in the database
    stop                        Stop corgi

EOF

    if [[ -n "$1" ]]; then
        echo "$@" >&2
    fi
    exit 1
}

_includes() {
    local search item
    search="$1"
    shift
    for item in "$@"; do
        if [[ "$search" == "$item" ]]; then
            return 0
        fi
    done
    return 1
}

start-leashed() {
    docker compose -f "$dev_stack" -f "$leash_stack" up --build --detach
}

start() {
    start-leashed
}

start-dev() {
    docker compose -f "$dev_stack" up --build --detach
    echo "Hint: Remember to setup your GitHub app like in the README" >&2
}

docker-run() {
    local stack_name stacks_allowed extra_args
    stack_name="$1"
    shift
    stacks_allowed=(dev leashed)
    extra_args=()
    if ! _includes "$stack_name" "${stacks_allowed[@]}"; then
        _die "You need to specify which stack to use (${stacks_allowed[*]})"
    fi
    if [[ "$stack_name" == "leashed" ]]; then
        extra_args+=(-f "$leash_stack")
    fi
    docker compose -f "$dev_stack" "${extra_args[@]:-}" "$@"
}

build() {
    docker-run "$@" build
}

_tests() {
    IMAGE_TAG=corgi-cli/corgi-ui-tests
    docker build -t $IMAGE_TAG -f backend/tests.dockerfile backend
    docker run --rm -it -v "$here/backend/app":/app -w /app $IMAGE_TAG \
        pytest --tb=long --showlocals "$@"
}

ui-tests() {
    local base_url token test_path
    base_url="$1"
    shift
    token="fake-token"
    test_path="./tests/ui"
    while test -n "$1"; do
        case "$1" in
            --token)
                token=$2
                shift
            ;;
            --test-path)
                test_path="$2"
                shift
            ;;
            *)
                {
                    echo "Usage:"
                    echo "      ui-tests [OPTIONS]"
                    echo "Options:"
                    echo "      --token         GitHub token to use for tests"
                    echo "      --test-path     Path to targeted tests"
                    echo "Unknown option: $1"
                } >&2
                return 1
            ;;
        esac
        shift
    done
    _tests --base-url "$base_url" --github-token "$token" "$@" "$test_path"
}

unit-tests-backend() {
    test_path="./tests/unit"
    while test -n "$1"; do
        case "$1" in
            --test-path)
                test_path="$2"
                shift
            ;;
            *)
                {
                    echo "Usage:"
                    echo "      unit-tests-backend [OPTIONS]"
                    echo "Options:"
                    echo "      --test-path     Path to targeted tests"
                    echo "Unknown option: $1"
                } >&2
                return 1
            ;;
        esac
        shift
    done
    _tests --snapshot-update "$@" "$test_path"
}

logs() {
    docker compose -f "$dev_stack" logs "$@"
}

stop() {
    docker compose -f "$dev_stack" down "$@"
}

create-erd() {
    {
        cat /dev/stdin <<eof
This section describes the data model used by CORGI. For more information
about how to read this diagram, see [Crow's foot notation](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#Crow's_foot_notation).
eof
        docker compose -f "$dev_stack" exec -w /app/app -T backend \
            python - < "$here/scripts/generate-erd.py"
    } | replace_readme_section "## " "CORGI ERD"
}

create-jobs() {
    local token
    # Should work in dev and leashed mode if token can be passed in
    token="${1:-fake-token}"
    docker compose -f "$dev_stack" exec -T backend \
        python - "$token" < "$here/scripts/create-jobs.py"
}

generate-migration() {
    docker compose exec backend alembic revision --autogenerate -m "$1"
}

create-approved-books() {
    local token
    token="${1:-fake-token}"
    docker compose -f "$dev_stack" exec -T backend \
        python - "$token" < "$here/scripts/add-approved-books.py"
}

lint() {
    docker compose -f "$dev_stack" run --rm backend ruff check
    docker compose -f "$dev_stack" run --rm backend ruff format --check
    docker compose -f "$dev_stack" run --rm frontend npm run lint
}

format() {
    local -
    set +e
    docker compose -f "$dev_stack" run --rm backend ruff check --fix
    docker compose -f "$dev_stack" run --rm backend ruff format
    docker compose -f "$dev_stack" run --rm frontend npm run format
}

replace_readme_section() {
    local section_prefix section_label full_label tmp_file readme_file \
        print_section
    section_prefix="${1:?}"
    section_label="${2:?}"
    full_label="${section_prefix}${section_label}"
    tmp_file="$(mktemp)"
    readme_file="$here/README.md"
    print_section='
        print "'"$full_label"'\n"
        print "[comment]: <> (BEGIN AUTO-GENERATED SECTION - '"$section_label"')"
        for(i=0; i<length(new_content); i++) {
            print new_content[i]
        }
        print "[comment]: <> (END AUTO-GENERATED SECTION - '"$section_label"')"

    '
    echo "Replacing README section ($full_label) ..." >&2
    {
        awk 'BEGIN {
            delete new_content["create array"]
        } {
            if (FNR == NR) {
                new_content[length(new_content)]=$0
                next
            }
            if (in_section == 1 && $0 ~ /^\s*'"$section_prefix"'/) {
                in_section = 0
            } else if ($0 ~ /^\s*'"$full_label"'/) {
                in_section = 1
                found_section = 1
                '"$print_section"'
            }
            if (in_section == 0) print
        } END {
            if (found_section != 1) {
                '"$print_section"'
            }
        }' <(cat) "$readme_file"
    } > "$tmp_file"
    mv "$tmp_file" "$readme_file"
}

build-frontend() {
    cd "$here/frontend"
    npm install
    npm run build
}

start-bare-metal() {
    local backend_path docker_path start_path app_path
    backend_path="$here/backend"
    app_path="$backend_path/app"
    docker_path="$backend_path/docker"
    start_path="$docker_path/start.sh"
    source "$repo_root/.env"
    cd "$app_path"
    PYTHONPATH="$app_path:$PYTHONPATH" \
    STACK_NAME="${STACK_NAME:-}" \
    TAG="${TAG:-}" \
    REVISION="${REVISION:-}" \
    DEPLOYED_AT="${DEPLOYED_AT:-}" \
    SESSION_SECRET="${SESSION_SECRET:-}" \
    GITHUB_API_TOKEN="${GITHUB_API_TOKEN:-}" \
    GITHUB_OAUTH_ID="${GITHUB_OAUTH_ID:-}" \
    GITHUB_OAUTH_SECRET="${GITHUB_OAUTH_SECRET:-}" \
    POSTGRES_SERVER="${POSTGRES_SERVER:-}" \
    POSTGRES_DB="${POSTGRES_DB:-}" \
    POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-}" \
    POSTGRES_USER="${POSTGRES_USER:-}" \
    PORT="${PORT:-8080}" \
    MODULE_NAME="${MODULE_NAME:-app.main}" \
    CALLABLE_NAME="${CALLABLE_NAME:-server}" \
    GUNICORN_CONF="${GUNICORN_CONF:-$docker_path/gunicorn.conf.py}" \
    PRE_START_PATH="${PRE_START_PATH:-$app_path/bin/prestart.sh}" \
    exec "$start_path"
}

here="$(cd "$(dirname "$0")" && pwd)"
repo_root="$here"
dev_stack="$here/docker-compose.stack.dev.yml"
leash_stack="$here/docker-compose.stack.leashed.yml"
readonly here repo_root dev_stack leash_stack

command_name="$1"
shift

: "${command_name:?}"

if ! _find_command "$command_name" >/dev/null; then
    _usage "Command not found: $command_name"
fi

$command_name "$@"
